= Doodle
Jakob Rathberger
1.3.0, 2021-12-27: Doodle
ifndef::imagesdir[:imagesdir: images]
//:toc-placement!:  // prevents the generation of the doc at this position, so it can be printed afterwards
:sourcedir: ../src/main/java
:icons: font
:sectnums:    // Nummerierung der Überschriften / section numbering
:toc: left

//Need this blank line after ifdef, don't know why...
ifdef::backend-html5[]

// print the toc here (not at the default position)
//toc::[]

== Datenmodell
[plantuml, cld, png, align=left]
----
include::plantuml/class.puml[]
----

== Kurze Erklärung

Eine Umfrage Platform für Termine.
Pro Umfrage gibt es mehrere Termine zum auswählen.
Für jede Abstimmung wird auch ein Name gespeichert.

== Technologien vom Unterricht
=== GraphQL
.PollResources
[source,java]
----
@GraphQLApi
@Path("/poll")
public class PollResource {

    @Inject
    PollRepository pollRepository;

    @Path("/id/{id}")
    @GET
    @Produces(MediaType.APPLICATION_JSON)
    public Response getPoll(@PathParam("id") String id) {
        Poll poll = pollRepository.findById(Long.valueOf(id));
        return Response.ok(
                poll
        ).build();
    }

    @Query("getSinglePoll")
    @Description("returns a single poll with the given id")
    public Poll getSinglePoll(@Name("pollId") long id){
        return pollRepository.findById(id);
    }
}
----
=== Qute

.PollResources
[source,java]
----
    @CheckedTemplate
    public static class Templates {
        public static native TemplateInstance poll(Poll poll);
    }

    @GET
    @Path("/page/id/{id}")
    @Produces(MediaType.TEXT_HTML)
    public TemplateInstance getPollPage(@PathParam("id") long id){
        return Templates.poll(pollRepository.findById(id));
    }
----
.poll.html
[source,html]
----
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>{poll.name}</title>
</head>
<body>
<h1>{poll.name}</h1>
<p1>{poll.description}</p1>
</body>
</html>
----

=== Validation
.Poll
[source,java]
----
@NotBlank(message="Name may not be blank")
@Size(min = 4, max = 100, message = "poll name should have size [{min},{max}]")
private String name;
@NotBlank(message="Description may not be blank")
@Size(min = 4, max = 255, message = "poll description should have size [{min},{max}]")
private String description;
----

.PollRepository
[source,java]
----
public void validatePoll(@Valid Poll poll){

}
----

.PollRepositoryTest
[source,java]
----
@Order(990)
@Test
void testPollValidation(){
    pollRepository.validatePoll(new Poll("Name1", "Desc1"));

    try {
        pollRepository.validatePoll(new Poll("Nam", "Des"));
    } catch (ConstraintViolationException e){

    }
}
----

=== gRPC

Since this Project does not use reactive and gRPC needs it, the gRPC Tutorials don't work.
Reason for this is that the quarkus-resteasy and quarkus-resteasy-reactive are not compatible.

Instead look at: https://github.com/JakobRathberger/grpc-quarkus-demo